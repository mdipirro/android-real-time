\section{Real-Time Specification for Java}
La RTSJ è stata creata per risolvere alcune delle limitazioni di Java nei confronti del mondo real-time. 

\subsection{Scheduling}
I thread real-time vengono gestiti con priorità (utilizzate veramente) attraverso uno scheduling preemptive e fixed-priority che utilizza un meccanismo di priority inheritance. In questo modo il thread con priorità più alta è sempre quello in esecuzione. Il meccanismo della priority inheritance garantisce che non si verifichi il fenomeno di inversione di priorità, ma non garantisce l'assenza di deadlock.

\subsection{Gestione della memoria}
RTSJ definisce due tipologie di aree di memoria (\textit{immortal} e \textit{scoped}) in aggiunta allo heap. Gli oggetti memorizzati in aree \textit{immortal} sono accessibili a tutti e non vengono mai spazzati dalla GC. Questa memoria è una risorsa limitata che va gestita con attenzione (dato che il GC non la pulisce). Ogni area \textit{scoped} è allocata con una dimensione massima e può essere utilizzata per allocare oggetti. L'interazione tra le tre diverse aree (immortal, scoped e heap) è governata da regole definite da RTSJ, così come il riutilizzo delle aree scoped. Queste regole sono però molto complesse, e l'uso delle due nuove aree è raccomandato solo per quei componenti che non possono tollerare le pause introdotte dal GC.

\subsection{Thread}
RTSJ aggiunge due nuovi tipi di thread che possono essere utilizzati in contesti real-time: \texttt{RealtimeThread} e {NoHeapRealtimeThread} (NHRT). Queste classi forniscono supporto per la gestione delle priorità, per la definizione di comportamenti periodici e di deadlines, con handlers da invocare nel caso di un miss. Gli NHRT non possono accedere allo heap e quindi non vengono interrotti dalla GC. Normalmente questi vengono utilizzati per task ad alta priorità e con requisiti temporali molto stretti. Il loro utilizzo richiede molta attenzione per evitare che salvino oggetti sullo heap. 

\subsection{Gestione di eventi asincroni}
RTSJ include supporto per la gestione di eventi asincroni generati da molteplici sorgenti: timers, segnali del sistema operativo, deadline mancate e altri eventi specifici dell'applicazione.