\section{Java per sistemi real-time}
L'uso di Java per sistemi real-time non è diffuso per varie ragioni. Le applicazioni Java vengono eseguite su una JVM in un sistema operativo general-purpose che può solo sperare di soddisfare requisiti di response time nell'ordine delle centinaia di millisecondi. Molti aspetti diversi del linguaggio sono responsabili di questi ritardi: la gestione dei thread, il caricamento dinamico delle classi, la compilazione Just-in-Time (JIT) e la garbage collection (GC). Alcune di questi effetti possono essere mitigati in fase di progettazione, ma solo con moltissimi sforzi. 

\subsection{Gestione dei thread}
Java non dà nessuna garanzia sullo scheduling o sull'utilizzo di priorità. Un'applicazione che deve rispondere agli eventi in un tempo ben definito non ha nessun modo di assicurare che un thread a bassa priorità non venga eseguito al posto di uno con priorità più alta. Per compensare, un programmatore dovrebbe dividere l'applicazione in ''sotto-applicazioni'' e farle eseguire a diverse priorità. Questo partizionamento, tuttavia, comporta una maggiore difficoltà di comunicazione e un overhead aggiuntivo.

\subsection{Caricamento dinamico delle classi}
Una JVM che rispetti la specifica di Java deve ritardare il caricamento delle classi fino a quando queste non vengono per la prima volta riferite nel programma. Il caricamento, quando avviene, può richiedere una quantità variabile di tempo, dipendentemente dal supporto fisico (disco o altro) dal quale la classe viene caricata e dalla dimensione. Generalmente il ritardo introdotto è oltre i 10ms. Di conseguenza, se decine o centinaia di classi vengono caricate, il caricamento può portare ad un ritardi significativo. Un design attento può caricare tutte le classi allo start-up, ma questa procedura va fatta manualmente.

\subsection{Garbage Collection}
La garbage collection ha vari benefici rispetto ad applicazioni classiche: pointer safety, leak avoidance e libera i programmatori dal dover gestire la memoria manualmente (tedioso e molto error-prone). Sfortunatamente però la garbage collection viene avviata automanticamente quando lo heap viene esaurito al punto tale che una richiesta di allocazione non può essere esaudita. Anche l'applicazione può chiedere una collection.

La pulizia della memoria avviene tramite la cosiddetta politica \textbf{Stopping the World}. L'applicazione viene messa in pausa per permettere al GC di pulire la memoria. Gli oggetti vivi vengono tracciati a partire da un insieme radice (oggetti puntati da campi statici, oggetti vivi nello stack dei thread, ecc). La memoria che non contiene questi oggetti viene libreata per una futura allocazione. Le pause introdotte dal GC sono illimitate in lunghezza e tipicamente sono molto intrusive (range centinaia di ms a secondi). La durata dipende dalla dimensione dello heap, dal numero di oggetti vivi e dal grado di aggressività del GC. Algoritmi più moderni utilizzano tecniche concorrenti o incrementali per ridurre il tempo di pausa, ma anche con queste tecniche non esiste un limite fissato alle attività di pulizia.

Se da un lato il non doversi preoccupare della gestione della memoria è un grande vantaggio, dall'altro la GC può introdurre pesanti ritardi, impossibili da prevedere staticamente. L'unica soluzione al problema è non usare affatto la GC, ma non è una soluzione praticabile sia per la complessità del codice da gestire sia perché difficilmente si possono trovare librerie esterne che non la utilizzano.

\subsection{Compilazione}
La maggior parte delle JVM commerciali compilano in codice nativo le parti dell'applicazione utilizzate più di frequente. Sfortunatamente l'esecuzione di codice compilato o interpretato avviene con tempi anche molto diversi tra loro. Per un'applicazione real-time l'impossibilità di prevedere quando il codice Java verrà compilato in codice nativo introduce troppo non determinismo per poter analizzare i tempi di esecuzione. Una soluzione è compilare a mano una lista di metodi che si sa essere eseguiti di frequente, ma l'operazione è molto error-prone.